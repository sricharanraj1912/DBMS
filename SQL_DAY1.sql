USE TASKMANAGEMENT
--SIMPLE SELECT
SELECT * FROM EMPLOYEE

-- SELECT WITHOUT FROM
SELECT 'WITHOUT USING CLAUSE' AS [MESSAGE],
	'1001' AS [CODE NUMBER],
	'HA HA' AS COMMENTS

-- SELECT USING VARIABLE
DECLARE @VARNAME NVARCHAR(50)
SET @VARNAME='NEW VALUE'

SELECT @VARNAME AS [USING VAR]


-- SELECT TO ASSIGN NEW VALUE TO AVRIABLE

DECLARE @VAR2 INT
SET @VAR2=1001

SELECT @VAR2 =11002

SELECT @VAR2 AS VAR2

--SELECT TOP FEW RECORDS

SELECT TOP 2 EMPID,EMPNAME FROM EMPLOYEE

--SELECT WITH ORDER BY ASC

SELECT * FROM EMPLOYEE ORDER BY EMPNAME ASC

--SELECT WITH ORDER BY DESC

SELECT * FROM EMPLOYEE ORDER BY EMPNAME DESC

-- GET NEWEST EMPLOYEE WHO JOINED

SELECT TOP 1 * FROM EMPLOYEE ORDER BY EMPID DESC

-- GET DISTINCT RECORDS FROM TABLE
-- 1. GET DISTINCT NAMES OF EMPLOYEES

SELECT DISTINCT EMPNAME FROM EMPLOYEE

-- 2. GET DISTINCT EMPLOYEE IDS OF NAMEES

SELECT DISTINCT EMPID, EMPNAME FROM EMPLOYEE

--SELECT WITH WHERE CLAUSE

SELECT * FROM EMPLOYEE WHERE EMPNAME='NITHYA' AND EMPID=1001

SELECT * FROM EMPLOYEE WHERE EMPNAME='NITHYA' OR EMPID=1000

SELECT TOP 2* FROM EMPLOYEE WHERE EMPNAME <> 'NITHYA' 

SELECT * FROM EMPLOYEE WHERE EMPNAME IN('SRICHARAN','NITHYA')

SELECT * FROM EMPLOYEE WHERE EMPNAME NOT IN('SRICHARAN','NITHYA')

SELECT * FROM EMPLOYEE WHERE DOJ BETWEEN '01-01-1990' AND '01-01-2020'

SELECT * FROM EMPLOYEE WHERE EMPNAME LIKE 'B%' -- EMP NAME STARTING WITH B--

SELECT * FROM EMPLOYEE WHERE EMPNAME LIKE '% %'   -- EMP NAME THAT HAVE 1 SPACE 

SELECT * FROM EMPLOYEE WHERE EMPNAME LIKE '_R%' -- EMPNAME WITH 2ND CHAR AS "R"

SELECT * FROM EMPLOYEE WHERE EMPNAME LIKE '%Y' -- EMP NAME ENDING WITH Y

-- NESTED SELECT STATEMNTS IN PLACE OF COLUMNS

SELECT( SELECT EMPNAME FROM EMPLOYEE WHERE EMPID=1003) AS [EMPLOYEE NAME], (SELECT 5+5) AS [PERCENT HIKE]

-- SELECT STSTEMENTS TO ASSIGN VALUES TO VARIABLE

DECLARE @EMPID INT
SET @EMPID=( SELECT  TOP 1 EMPID FROM EMPLOYEE WHERE EMPNAME='NITHYA')
SELECT @EMPID AS [ ASSIGNED EMP]

-- SELECT STATMENT TO ASSIGN AND PRINT VALUE OF A VARIABLE
DECLARE @NEWVALUE INT
SELECT @NEWVALUE=(SELECT TOP 1 EMPID FROM EMPLOYEE WHERE EMPNAME='NITHYA')
SELECT @NEWVALUE

-- PRINT AS A LOG MESG, CHECK MSG TAB OF RESULT WINDOW. USED CAST() TO TYPECASTE DIFF DATA TYPE
PRINT ' THE VALUE OF @NEWVALUE ='+CAST(@NEWVALUE AS NVARCHAR)

--CLONE A TABLE( TO BACKUP TABLE QUICKLY)
SELECT * INTO EMPCLONE
FROM EMPLOYEE


--CREATE A QUICK BACKUP
SELECT * INTO EMPBACKUP
FROM EMPLOYEE
WHERE MANAGERID IS NOT NULL


--CLONE A TABLE( TO BACKUP TABLE QUICKLY)

SELECT * INTO EMPCLONEE
FROM EMPLOYEE
WHERE 0=1 --BY USING THIS WE COPY ONLY THE STRUCTUTRE NOT THE WHOLE TABLE

SELECT * FROM EMPCLONEE


-- USING SELECT WITH MORE THAN ONE TABLES

 -- DISPLAY EMPNAMES WITH TASKIDS

 SELECT E.EMPNAME,ET.TASKID FROM EMPLOYEE E,EMPTASK ET
 WHERE E.EMPID=ET.EMPID

  -- DISPLAY TASK NAMES WITH EMP ID
  SELECT ET.EMPID, T.TASKNAME FROM EMPTASK ET, TASKTABLE T
  WHERE ET.TASKID=T.TASKID

  -- ALL EMPNAMES WITH THEIR CORRESPONDING TASK NAMES
  SELECT E.EMPNAME ,T.TASKNAME FROM EMPLOYEE E, TASKTABLE T, EMPTASK ET
  WHERE E.EMPID=ET.EMPID AND ET.TASKID= T.TASKID

  --GET EMPNAMES WITH THEIR CORRESPONDING TASK ID
  SELECT E.EMPNAME, ET.TASKID FROM EMPLOYEE AS E INNER JOIN EMPTASK AS ET ON E.EMPID=ET.EMPID

  -- TASK NAME AND MATCHING EMPID
  SELECT T.TASKNAME, ET.EMPID FROM TASKTABLE T INNER JOIN EMPTASK AS ET ON T.TASKID=ET.TASKID

  --GET EMPNAME EITH CORRESPONDING TASK NAME

  SELECT E.EMPNAME, T.TASKNAME FROM EMPLOYEE E INNER JOIN EMPTASK ET ON E.EMPID=ET.EMPID
   INNER JOIN TASKTABLE T ON ET.TASKID=T.TASKID

-- TASKNAMES  ASSIGNED TO ALL EMPIDS
SELECT T.TASKNAME, ET.EMPID FROM TASKTABLE T RIGHT  OUTER JOIN EMPTASK ET ON T.TASKID=ET.TASKID

-- TASKID FOR ALL EMPNAMES
SELECT ET.TASKID, E.EMPNAME FROM EMPLOYEE E LEFT OUTER JOIN EMPTASK ET ON E.EMPID=ET.EMPID

SELECT ET.TASKID, E.EMPNAME FROM EMPTASK ET RIGHT OUTER JOIN EMPLOYEE E ON ET.EMPID=E.EMPID

-- FULL OUTER JOIN

SELECT  E.EMPNAME, ET.TASKID FROM EMPLOYEE E FULL OUTER JOIN  EMPTASK ET ON E.EMPID=ET.EMPID

--CROSS JOIN EMPLOYEE AND TASK TABLE

SELECT E.EMPNAME , T.TASKNAME FROM EMPLOYEE  AS E CROSS JOIN TASKTABLE T

--NATURAL JOIN

SELECT E.EMPNAME , ET.TASKID FROM EMPLOYEE  AS E JOIN EMPTASK ET ON E.EMPID=ET.EMPID


--CREATE VIEWS

CREATE VIEW VW_EMPTASKNAMES AS
SELECT E.EMPNAME,T.TASKNAME FROM EMPLOYEE AS E LEFT OUTER JOIN EMPTASK AS ET ON E.EMPID=ET.EMPID
LEFT OUTER JOIN TASKTABLE AS T ON T.TASKID=ET.TASKID

--EXECUTE VIEW
SELECT * FROM VW_EMPTASKNAMES

--CREATE PROCEDURE ( STORED PROCEDURE IS AFUNCTION WITHOUT RETURN STATEMENT
CREATE PROCEDURE SP_GETEMPTASKNAMES AS
SELECT E.EMPNAME,T.TASKNAME FROM EMPLOYEE AS E LEFT OUTER JOIN EMPTASK AS ET ON E.EMPID=ET.EMPID
LEFT OUTER JOIN TASKTABLE AS T ON T.TASKID=ET.TASKID

--EXECUTE SP

EXEC SP_GETEMPTASKNAMES

-- STORED PROCEDURE WITH PARAMETERES , ALL VARIABLES IN SQL START WITH @ SYMBOL

CREATE PROCEDURE SP_GETTASKNAMEFOREMPLOYEEEE @EMPNAME NVARCHAR(50)
AS
SELECT E.EMPNAME, T.TASKNAME FROM EMPLOYEE AS E LEFT OUTER JOIN EMPTASK AS ET ON E.EMPID=ET.EMPID
LEFT OUTER JOIN TASKTABLE AS T ON T.TASKID=ET.TASKID
WHERE E.EMPNAME=@EMPNAME 

EXEC SP_GETTASKNAMEFOREMPLOYEEEE 'NITHYA' 

-- ALTER
ALTER PROCEDURE SP_GETTASKNAMEFOREMPLOYEEEE @EMPNAME NVARCHAR(50)
AS
SELECT E.EMPNAME, T.TASKNAME FROM EMPLOYEE AS E LEFT OUTER JOIN EMPTASK AS ET ON E.EMPID=ET.EMPID
LEFT OUTER JOIN TASKTABLE AS T ON T.TASKID=ET.TASKID
WHERE E.EMPNAME=@EMPNAME AND T.TASKNAME IS NOT NULL

EXEC SP_GETTASKNAMEFOREMPLOYEEEE 'SRICHARAN'

--SCALAR FUNCTION HAS ONLY SINGLE FUNCTION

-- SCALAR FUNCTION MUST HAVE RETURN KEYWORD

CREATE FUNCTION FN_GETTASKNAMEFOREMPLOYEE(@EMPNAME NVARCHAR(50))
RETURNS NVARCHAR(50)
AS
BEGIN 
RETURN ( SELECT TOP 1 T.TASKNAME FROM EMPLOYEE E LEFT OUTER JOIN EMPTASK ET ON E.EMPID=ET.EMPID
LEFT OUTER JOIN  TASKTABLE T ON T.TASKID=ET.TASKID
WHERE E.EMPNAME=@EMPNAME AND T.TASKNAME IS NOT NULL)
END


-- EXECUTE

SELECT [DBO].[FN_GETTASKNAMEFOREMPLOYEE]('SRICHARAN')

-- TO GET TOTAL TASK FOR EMPLOYEE

CREATE FUNCTION FN_GETTOTALTASKFOREMPLOYEE(@EMPNAME NVARCHAR(50))
RETURNS NVARCHAR(50)
AS
BEGIN 
RETURN ( SELECT COUNT(T.TASKNAME) FROM EMPLOYEE E LEFT OUTER JOIN EMPTASK ET ON E.EMPID=ET.EMPID
LEFT OUTER JOIN  TASKTABLE T ON T.TASKID=ET.TASKID
WHERE E.EMPNAME=@EMPNAME AND T.TASKNAME IS NOT NULL)
END


-- EXECUTE

SELECT [DBO].[FN_GETTOTALTASKFOREMPLOYEE]('SRICHARAN')

-- GET TOTAL TASK FOR EACH GUY USING GROUP, GROUP EACH GUY BASED ON TASK AND FIND THE TOTAL PPL IN THAT GROUP

SELECT E.EMPNAME, COUNT(T.TASKNAME) AS TASKCOUNT FROM EMPLOYEE E LEFT OUTER JOIN EMPTASK ET ON E.EMPID=ET.EMPID
LEFT OUTER JOIN  TASKTABLE T ON T.TASKID=ET.TASKID
GROUP BY E.EMPNAME

-- TO USE GROUP BY
-- 1. IT MUST HAVE AGGREGATION FUNCTION
--2. MUST HAVE ATLEAST 1 OTHER COLUMN THAT DOESNT USE AGGREAGATION FUNCTION
--EG COUNT(T.[NAME]): COLUMN USED AGGREGATEION FUNC
--EG. EMPNAME IS THE OTHR COULM WITHOUT AGGREGATION FUNCTION

SELECT E.EMPNAME, ET.TASKID, COUNT(T.TASKNAME) AS TASKCOUNT FROM EMPLOYEE E LEFT OUTER JOIN EMPTASK ET ON E.EMPID=ET.EMPID
LEFT OUTER JOIN  TASKTABLE T ON T.TASKID=ET.TASKID
GROUP BY E.EMPNAME, ET.TASKID

--

--SAME QUERY WITH ALL OFTHEM HAVING TASK COUNT O;

SELECT E.EMPNAME, ET.TASKID, COUNT(T.TASKNAME) AS TASKCOUNT FROM EMPLOYEE E LEFT OUTER JOIN EMPTASK ET ON E.EMPID=ET.EMPID
LEFT OUTER JOIN  TASKTABLE T ON T.TASKID=ET.TASKID
GROUP BY E.EMPNAME, ET.TASKID
HAVING COUNT(T.TASKNAME)=0

-- insert

insert into tasktable values('coding', '10-25-2023', '12-18-2023')

insert into tasktable
select 'sqllabwork','10-23-2023','12-18-2023'
union all
select 'design','10-24-2023','12-18-2023'
union all
select 'test','10-25-2023','12-18-2023'


select * into taskbackup
from tasktable

select * from taskbackup


update taskbackup set taskname ='sql'
where taskid=2

-- program to update the taskid 
declare @taskid int,@counter int
set @taskid=1
set @counter=1

while(@taskid<=18)
begin
	update taskbackup set taskname='day'+cast(@counter as nvarchar)+'labwork'

	where taskid=@taskid
	
	set @taskid=@taskid+1
	set @counter=@counter+1

end

select * from taskbackup

-- delete
delete from taskbackup where taskid in (17,18)

-- insert with select from the other table

insert into tasktable select taskname,startdate,endtime from taskbackup


select * from tasktable
update tasktable set taskname = 'day101'
where taskid=12

select * from tasktable

--transaction

select * from tasktable

begin transaction 
	insert into tasktable select 'new task 1','10-27-2023','12-18-2023'
	print ' newly created taskid='+cast(@@identity as nvarchar)
	delete from tasktable where taskid=@@identity
commit

select * from tasktable

--------------------------------------------------------------------
--cursor
create procedure procedurename as
begin
declare @empid int, @empname nvarchar(40), @managerid int, @doj as datetime
declare c1 cursor  for
select empid, empname, doj, managerid from EMPloyee
where isactive =1

open c1
fetch next from c1
into @empid, @empname, @doj,@managerid
print 'in cursor'
while @@FETCH_STATUS=0
begin
 if @doj > '01-01-2022' and @doj < '12-31-2023'
  print @empname+'increment-10%'

  else if @doj between ' 01-01-2021' and '12-31-2023'
  print @empname+'increment-20%'
  
 else  if @doj between '01-01-2020' and '12-31-2023'
  print @empname+'increment-30%'

fetch next from c1 into @empid, @empname, @doj,@managerid
end

close c1
deallocate c1

end


exec procedurename

--------same get a csv
-- get comma seperated employee names
--analysis sql feature : cursor coz record by record processing	
create function fnemptocsv()
returns nvarchar(max)
as
begin
declare @empname nvarchar(max), @result nvarchar(max)
declare c1 cursor for 
select empname from employee
open c1
fetch next from c1
into @empname

-- initialy a var will be null so anything concatenated to it will also be null so give its value as empty
set @result=''
while @@FETCH_STATUS=0
begin

--actual logic
set @result=@result+@empname+','
fetch next from c1
into @empname
end
close c1
deallocate c1
return @result

end
go
select  DBO.fnemptocsv() as [empname]